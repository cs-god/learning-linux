	参考文档:https://blog.csdn.net/HUAERBUSHI521/article/details/118599134
# 一、虚拟地址空间

直接使用物理内存面临的问题:
- 内存缺乏访问控制,安全性不足
- 各进程同时访问物理内存,可能会互相产生影响,没有独立性
- 物理内存极小,而并发进程所需又大,容易导致内存不足
- 进程所需空间不一,容易导致内存碎片化问题
基于以上几种原因,Linux通过<font color=44cf57>mm_struct结构体</font>描述了一个虚拟的，连续的，独立的地址空间，也就是所说的虚拟地址空间。

程序运行时,在建立了虚拟地址空间后,并没有分配实际的物理内存,而是当进程需要实际访问内存资源的时候就会由内核的请求分页机制产生缺页中断,这时才会建立虚拟地址和物理地址的映射,调入物理内存页.通过这种方式,就能够保证我们的物理内存只有在实际使用时才进行分配,避免了内存浪费的问题。

# 二、虚拟地址空间分布

在linux中，虚拟地址空间的内部又被划分为<font color=44cf57>用户空间</font>与<font color=44cf57>内核空间</font>。

<img src="D:\Obsidian\note_obsidian\Linux\进程篇\pic\虚拟空间.png" width=40%/>

## 2.1 内核态与用户态的理解

内核态:本质是一种特殊的软件程序,控制计算机的硬件资源,比如:协调CPU资源,分配内存资源,并且提供稳定的环境供应用程序运行.

用户态:提供应用程序运行的空间,为了使应用程序能够访问的内核管理的资源

系统调用:是操作系统最小的功能单位,是用户态和内核态交互的基本接口.

库函数:实际是对系统调用进行封装,提供简单的基本接口给用户.屏蔽了复杂的底层实现细节,增强了程序的灵活性.  库函数根据不同的标准有不同的标准:glibc库,posix库

内核态和用户态的区别本质是:权限不同

从用户态到内核态切换的三种方式:系统调用,异常,外设中断

## 2.2 用户空间

栈：又叫堆栈，用于存放非静态局部变量，函数参数，返回值等。栈是向下增长的，每当一个函数被调用时，就会将参数压入进程调用栈中，调用结束后返回值也会被放回栈中。同时，每调用一次函数就会创建一个新的栈，所以在递归较深时容易导致栈溢出。栈内存的申请和释放由编译器自动完成，并且栈容量由系统预先定义。
内存映射段: 是高效的I/0映射方式,用于装载一个共享的动态内存库.用户可使用系统接口创建共享内存,做进程间通信.
堆:用于存放程序运行时动态内存分配,堆内存由用户申请分配和释放,堆是向上增长的
BSS段:用来存放程序中未初始化的全局变量和静态变量。

数据段:用来存放程序中已初始化全局变量与静态变量。

代码段：代码段用来存放程序执行代码，也可能包含一些只读的常量。这块区域的大小在程序运行时就已经确定，并且为了防止代码和常量遭到修改，代码段被设置为只读。

## 2.3 内核空间
内核空间即进程陷入内核态后才能访问的空间.虽然每个进程都具有自己独立的虚拟地址空间,但是这些虚拟地址空间中的内核空间(前896M),其实关联的都是同一块物理内存.



 通过这种方法,保证了进程在切换至内核态后能够快速的访问内核空间.

内核空间虚拟地址X 对于的物理内存地址:X-0xc0000000

内核空间虚拟地址分布:


 内核空间主要分为直接映射区和高端内存映射区.

直接映射区:

从内核空间起始位置开始，从低地址往高地址增长，最大为896M的区域即为直接映射区。直接映射区的896M的虚拟地址与物理地址的前896M进行直接映射.因此虚拟地址和分配的物理地址都是连续的。

相互转换: 偏移量PAGE_OFFSET:0xC0000000    物理地址 = 虚拟地址-PAGE_OFFSET

高端内存映射区:

内核空间大小只有1G,但是物理内存可不止1G.内核空间利用直接映射区将896M的内存直接映射到物理内存中,那么剩下的物理内存寻址工作,就交给了高端内存映射区.

将剩下的128M的空间划分为三个高端内存的映射区,从上往下分别是:固定内存映射区,永久内存映射区,动态内存映射区.

动态内存映射区:该区域的特点是虚拟地址连续，但是其对应的物理地址并不一定连续。该区域使用内核函数vmalloc进行分配，分配的虚拟地址的物理页可能会处于低端内存，也可能处于高端内存
永久内存映射区:该区域可以访问高端内存。使用alloc_page(_GFP_HIGHMEM)分配高端内存页，或者使用kmap将分配的高端内存映射到该区域
固定内存映射区: 该区域的每个地址项都服务于特定的用途
三.虚拟地址空间的映射
 3.1 物理内存分页
在Linux系统中,通过分段分页的机制,将物理内存划分为4k大小的内存页,并且将页作为物理内存分配与回收的基本单位.

内核会为每一个物理页帧创建一个struct page结构体,其中包含的重要信息有:

flags:描述page的状态和其它信息
index: 在映射的虚拟空间(vma_area)内的偏移
lru: 链表头,用于各种链表上维护该页,以便于按页将不同类别分组
3.2 管理区页框分配器
Linux内核通过一个管理区页框分配器管理着物理内存上所有的页框,在管理分配器里的核心系统就是伙伴系统和每CPU高速缓存.  在linux系统中,管理区页框分配器管理着所有物理内存,无论是内核还是用户进程,需要将一些内存占为己有时,都需要请求管理区页框分配器,这时才会给你分配物理内存页框.

3.3 vm_area_structs[区域结构链表]
一个具体的区域结构vm_area_struct包含的重要字段:

vm_start: 指向这个区域的起始处
vm_end: 指向这个区域的结束处
vm_port: 描述这个区域内包含的所有页面的读写许可权限
vm_falgs: 描述这个区域内的页面是否是与其它进程共享的,还是这个进程私有的
vm_next: 指向链表中的下一个区域结构


每一个 vm_area_struct 结构体描述了一片特定的虚拟地址空间.

四.物理内存的管理
4.1 内存碎片问题
在Linux中,通过分段和分页的机制,将物理内存划分为4K大小的内存页,并且将页作为物理内存分配与回收的基本单位.通过分页机制可以灵活的对内存进行管理.

如果用户申请小块内存,可以直接分配一页给用户,就可以必秒因为频繁的申请,释放小块内存而发起的系统调用带来的消耗
如果用户申请了大块内存,可以将多个页框组合成一大块内存后再进行分配,非常灵活. 
但是这种直接的内存分配存在着大量的问题,非常容易导致内存碎片的问题.下面就分别介绍两种内存碎片:内部碎片和外部碎片.

外部碎片:

当我们需要分配大块内存的时,操作系统会将连续的页框组合起来形成大块内存,再将其分配给用户.但是频繁的申请和释放内存页,就会带来内存外碎片的问题.

 当需要分配大块内存的时候，要用好几页组合起来才够，而系统分配物理内存页的时候会尽量分配连续的内存页面，频繁的分配与回收物理页导致大量的小块内存夹杂在已分配页面中间，形成内存外碎片.

内部碎片:

由于页是物理内存分配的基本单位,因此即使我们需要的内存很小,Linux也会至少给我们分配4K的内存页.



倘若我们需求的只有几个字节,那么该内存中有大量的空间未被使用,造成了内存浪费的问题.而我们频繁进行小块内存的申请,这种浪费现象就会愈发严重,这也就是内存内碎片的问题. 

4.2 伙伴系统(buddy system)
要想解决内存外碎片的问题，无非就两种方法

内存外碎片问题的本质就是空间不连续，所以可以将非连续的空闲页框映射到连续的虚拟地址空间
记录现存的空闲连续页框块的情况，尽量避免为了满足小块内存的请求而分割大的空闲块。
Linux选择了第二种方法来解决这个问题，即引入伙伴系统算法，来解决内存外碎片的问题。
 

伙伴系统就是把相同大小的连续空闲页框块用链表串起来,这样页框之间看起来就像是手拉手的伙伴,这也是其名字的由来.

伙伴系统将所有的空闲页框分组为11块链表,每个块链表分别包含大小为1,2,4,8,16,32,64,128,256,512和1024个连续页框的页框块,即2的0~10次方,最大可以申请1024个连续页框,对应4MB(1024*4K)大小的连续内存.每个页框块的第一个页框的物理地址应该是该块大小的整数倍.


 因为任何正整数都可以由 2^n 的和组成，所以我们总能通过拆分与合并，来找到合适大小的内存块分配出去，减少了外部碎片产生 。

4.3 slab分配器
 伙伴系统很好的解决了内存外碎片的问题,但是它还是以页作为内存分配和释放的基本单位.而我们在实际的应用中则是以字节为单位.例如我们申请2个字节的空间,但是其还是会向我们分配一页,也就是4096字节的内存,因此还是会存在内存碎片的问题.

为了解决这个问题，slab分配器就应运而生了。其以字节为基本单位，专门用于对小块内存进行分配。slab分配器并未脱离伙伴系统，而是对伙伴系统的补充，它将伙伴系统分配的大内存进一步细化为小内存分配。

对于内核对象，生命周期通常是这样的：分配内存->初始化->释放内存。而内核中如文件描述符、pcb等小对象又非常多，如果按照伙伴系统按页分配和释放内存，不仅存在大量的空间浪费，还会因为频繁对小对象进行分配-初始化-释放这些操作而导致性能的消耗。

所以为了解决这个问题，对于内核中这些需要重复使用的小型数据对象，slab通过一个缓存池来缓存这些常用的已初始化的对象。

当我们需要申请这些小对象时，就会直接从缓存池中的slab列表中分配一个出去。而当我们需要释放时，我们不会将其返回给伙伴系统进行释放，而是将其重新保存在缓存池的slab列表中。通过这种方法，不仅避免了内存内碎片的问题，还大大的提高了内存分配的性能。

下面就由大到小，来画出底层的数据结构



 

kmem_cache是一个cache_chain的链表，描述了一个高速缓存，这个缓存可以看做是同类型对象的一种储备，每个高速缓存包含了一个slab的列表，这通常是一段连续的内存块，并包含3种类型的slabs链表：

slabs_full(完全分配的slab)
slabs_partial(部分分配的slab)
slabs_empty(空slab,或者没有对象被分配)。
slab是slab分配器的最小单位，在具体实现上一个slab由一个或者多个连续的物理页组成(通常只有一页)。单个slab可以在slab链表中进行移动，例如一个未满的slab节点，其原本在slabs_partial链表中，如果它由于分配对象而变慢，就需要从原先的slabs_partial中删除，插入到完全分配的链表slabs_full中

内核中slab分配对象的全过程:

根据对象的类型找到cache_chain中对应的高速缓存kmem_cache
如果slabs_partial链表中还有未分配的空间，则为其分配对象。如果分配对象之后空间已满，则移动slab节点到slabs_full链表
如果slabs_partial链表没有未分配的空间，则去查看slabs_empty链表
如果slabs_empty链表还有未分配的空间，则为其分配对象，同时移动slab节点进入slabs_partial链表中
如果slabs_empty链表也没有未分配的空间，则说明此时空间不足，就会请求伙伴系统分页，并创建新的空闲slab节点放入slabs_empty链表中，回到步骤4。
从上面可以看出，slab分配器的本质其实就是通过将内存按使用对象不同再划分成不同大小的空间，即对内核对象的缓存操作.

slab分配器的优点:

slab内存管理基于内核小对象,不用每次都分配一页内存,充分利用空间,避免内部碎片
slab对内核中频繁创建和释放的小对象做缓存,重复利用一些相同的对象,减少内存分配次数.
————————————————
版权声明：本文为CSDN博主「嫌疑人X的替身」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/HUAERBUSHI521/article/details/118599134
























进程地址空间中分为各个不同的部分： 

- 内核空间
  - 由于系统内核中有些代码、数据是所有进程所公用的，所以所有进程的进程地址空间中有一个专门的区域存放公共的内核代码和数据，该区域内的内容相同，且该虚拟内存映射到同一个物理内存区域。 
  - 进程在执行的时候，需要维护进程相关的数据结构，比如页表、task和mm结构、内核栈等，这些数据结构是进程独立的，各个进程之间可能不同。这些数据结构在进程虚拟地址空间中一个专门的区域中。 
- 用户空间
  - 用户栈
    - 进程在进行函数调用的时候，需要使用栈，于是进程地址空间中存在一个专门的虚拟内存区域维护用户栈。 
  - 共享库的虚拟内存映射
    - 进程执行的时候可能会调用共享库，在进程地址空间中有一个共享库的存储器映射区域，这个是进程独立的，因为每个进程可能调用不同的共享库。
  - 堆
    - 进程在进行动态内存分配的时候，需要使用堆，于是进程地址空间中存在一个专门的虚拟内存区域维护堆。 
  - .bss段
  - .data段
  - .text段
  - 保留空间

​     linux系统中进程的地址空间分布如下图所示，其中在32位系统中0-3GB为用户空间，3-4GB为内核空间：

![img](D:\note\Linux\aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTQ0ODg4MC8yMDE4MTAvMTQ0ODg4MC0yMDE4MTAxNzEwNTc1Mzg4MC0xNDI4MTk3MzAzLnBuZw)

###  1 内核空间

​    内核总是驻留在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。

### 2 栈(stack)

​    栈又称堆栈，由编译器自动分配释放，行为类似[数据结构](https://so.csdn.net/so/search?q=数据结构&spm=1001.2101.3001.7020)中的栈(先进后出)。堆栈主要有三个用途：

- 为函数内部声明的非静态局部变量(C语言中称“自动变量”)提供存储空间。
- 记录函数调用过程相关的维护性信息，称为栈帧(Stack Frame)或过程活动记录(Procedure Activation Record)。它包括函数返回地址，不适合装入寄存器的函数参数及一些寄存器值的保存。除递归调用外，堆栈并非必需。因为编译时可获知局部变量，参数和返回地址所需空间，并将其分配于BSS段。
- 临时存储区，用于暂存长算术表达式部分计算结果或alloca()函数分配的栈内内存。

​    持续地重用栈空间有助于使活跃的栈内存

保持在CPU缓存中，从而加速访问。进程中的每个线程都有属于自己的栈。向栈中不断压入数据时，若超出其容量就会耗尽栈对应的内存区域，从而触发一个页错误。此时若栈的大小低于堆栈最大值RLIMIT_STACK(通常是8M)，则栈会动态增长，程序继续运行。映射的栈区扩展到所需大小后，不再收缩。

​    Linux中ulimit -s命令可查看和设置堆栈最大值，当程序使用的堆栈超过该值时, 发生栈溢出(Stack Overflow)，程序收到一个段错误(Segmentation Fault)。注意，调高堆栈容量可能会增加内存开销和启动时间。

​    堆栈既可向下增长(向内存低地址)也可向上增长, 这依赖于具体的实现。本文所述堆栈向下增长。

​    堆栈的大小在运行时由内核动态调整。

### 3 内存映射段(mmap)

​    此处，内核将硬盘文件的内容直接映射到内存, 任何应用程序都可通过Linux的mmap()系统调用或Windows的CreateFileMapping()/MapViewOfFile()请求这种映射。内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库。用户也可创建匿名内存映射，该映射没有对应的文件, 可用于存放程序数据。在 Linux中，若通过malloc()请求一大块内存，C运行库将创建一个匿名内存映射，而不使用堆内存。”大块” 意味着比阈值 MMAP_THRESHOLD还大，缺省为128KB，可通过mallopt()调整。

​    该区域用于映射可执行文件用到的动态链接库。在Linux 2.4版本中，若可执行文件依赖共享库，则系统会为这些动态库在从0x40000000开始的地址分配相应空间，并在程序装载时将其载入到该空间。在Linux 2.6内核中，共享库的起始地址被往上移动至更靠近栈区的位置。

​    从进程地址空间的布局可以看到，在有共享库的情况下，留给堆的可用空间还有两处：一处是从.bss段到0x40000000，约不到1GB的空间；另一处是从共享库到栈之间的空间，约不到2GB。这两块空间大小取决于栈、共享库的大小和数量。这样来看，是否应用程序可申请的最大堆空间只有2GB？事实上，这与Linux内核版本有关。在上面给出的进程地址空间经典布局图中，共享库的装载地址为0x40000000，这实际上是Linux kernel 2.6版本之前的情况了，在2.6版本里，共享库的装载地址已经被挪到靠近栈的位置，即位于0xBFxxxxxx附近，因此，此时的堆范围就不会被共享库分割成2个“碎片”，故kernel 2.6的32位Linux系统中，malloc申请的最大内存理论值在2.9GB左右。

### 4 堆(heap)

​    堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。当进程调用malloc(C)/new(C++)等函数分配内存时，新分配的内存动态添加到堆上(扩张)；当调用free(C)/delete(C++)等函数释放内存时，被释放的内存从堆中剔除(缩减) 。

​    分配的堆内存是经过字节对齐的空间，以适合原子操作。堆管理器通过链表管理每个申请的内存，由于堆申请和释放是无序的，最终会产生内存碎片。堆内存一般由应用程序分配释放，回收的内存可供重新使用。若程序员不释放，程序结束时操作系统可能会自动回收。

​    堆的末端由break指针标识，当堆管理器需要更多内存时，可通过系统调用brk()和sbrk()来移动break指针以扩张堆，一般由系统自动调用。

​    使用堆时经常出现两种问题：1) 释放或改写仍在使用的内存(“内存破坏”)；2)未释放不再使用的内存(“内存泄漏”)。当释放次数少于申请次数时，可能已造成内存泄漏。泄漏的内存往往比忘记释放的数据结构更大，因为所分配的内存通常会圆整为下个大于申请数量的2的幂次(如申请212B，会圆整为256B)。

​    注意，堆不同于数据结构中的”堆”，其行为类似链表。

###  5 BSS段 

​    BSS(Block Started by Symbol)段中通常存放程序中以下符号：

- 未初始化的全局变量和静态局部变量
- 初始值为0的全局变量和静态局部变量(依赖于编译器实现)
- 未定义且初值不为0的符号(该初值即common block的大小)

​    C语言中，未显式初始化的静态分配变量被初始化为0(算术类型)或空指针(指针类型)。由于程序加载时，BSS会被操作系统清零，所以未赋初值或初值为0的全局变量都在BSS中。BSS段仅为未初始化的静态分配变量预留位置，在目标文件中并不占据空间，这样可减少目标文件体积。但程序运行时需为变量分配内存空间，故目标文件必须记录所有未初始化的静态分配变量大小总和(通过start_bss和end_bss地址写入机器代码)。当加载器(loader)加载程序时，将为BSS段分配的内存初始化为0。在嵌入式软件中，进入main()函数之前BSS段被C运行时系统映射到初始化为全零的内存(效率较高)。

​    注意，尽管均放置于BSS段，但初值为0的全局变量是强符号，而未初始化的全局变量是弱符号。若其他地方已定义同名的强符号(初值可能非0)，则弱符号与之链接时不会引起重定义错误，但运行时的初值可能并非期望值(会被强符号覆盖)。因此，定义全局变量时，若只有本文件使用，则尽量使用static关键字修饰；否则需要为全局变量定义赋初值(哪怕0值)，保证该变量为强符号，以便链接时发现变量名冲突，而不是被未知值覆盖。

​    某些编译器将未初始化的全局变量保存在common段，链接时再将其放入BSS段。在编译阶段可通过-fno-common选项来禁止将未初始化的全局变量放入common段。

​    此外，由于目标文件不含BSS段，故程序烧入存储器(Flash)后BSS段地址空间内容未知。U-Boot启动过程中，将U-Boot的Stage2代码(通常位于lib_xxxx/board.c文件)搬迁(拷贝)到SDRAM空间后必须人为添加清零BSS段的代码，而不可依赖于Stage2代码中变量定义时赋0值。

### 6 数据段(Data)

​    数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态局部变量。数据段属于静态内存分配(静态存储区)，可读可写。数据段保存在目标文件中(在嵌入式系统里一般固化在镜像文件中)，其内容由程序初始化。例如，对于全局变量int gVar = 10，必须在目标文件数据段中保存10这个数据，然后在程序加载时复制到相应的内存。

​    数据段与BSS段的区别如下： 

   1) BSS段不占用物理文件尺寸，但占用内存空间；数据段占用物理文件，也占用内存空间。

​    对于大型数组如int ar0[10000] = {1, 2, 3, ...}和int ar1[10000]，ar1放在BSS段，只记录共有10000*4个字节需要初始化为0，而不是像ar0那样记录每个数据1、2、3...，此时BSS为目标文件所节省的磁盘空间相当可观。

   2) 当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。

​     运行时数据段和BSS段的整个区段通常称为数据区。某些资料中“数据段”指代数据段 + BSS段 + 堆。

### 7 代码段(text)

​    代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)。一般C语言执行语句都编译成机器代码保存在代码段。通常代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。代码段通常属于只读，以防止其他程序意外地修改其指令(对该段的写操作将导致段错误)。某些架构也允许代码段为可写，即允许修改程序。

​    代码段指令根据程序设计流程依次执行，对于顺序指令，只会执行一次(每个进程)；若有反复，则需使用跳转指令；若进行递归，则需要借助栈来实现。

​    代码段指令中包括操作码和操作对象(或对象地址引用)。若操作对象是立即数(具体数值)，将直接包含在代码中；若是局部数据，将在栈区分配空间，然后引用该数据地址；若位于BSS段和数据段，同样引用该数据地址。

​    代码段最容易受优化措施影响。 

###  8 保留区

​    位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况。

​    它并不是一个单一的内存区域，而是对地址空间中受到操作系统保护而禁止用户进程访问的地址区域的总称。大多数操作系统中，极小的地址通常都是不允许访问的，如NULL。C语言将无效指针赋值为0也是出于这种考虑，因为0地址上正常情况下不会存放有效的可访问数据。

​    在32位X86架构的Linux系统中，用户进程可执行程序一般从虚拟地址空间0x08048000开始加载。该加载地址由ELF文件头决定，可通过自定义链接器脚本覆盖链接器默认配置，进而修改加载地址。0x08048000以下的地址空间通常由C动态链接库、动态加载器ld.so和内核VDSO(内核提供的虚拟共享库)等占用。通过使用mmap系统调用，可访问0x08048000以下的地址空间。

​    每个进程都有自己独立的4G内存空间，各个进程的内存空间具有类似的结构。
Linux内存管理采用的是页式管理，使用的是多级页表，动态地址转换机构与主存、辅存共同实现[虚拟内存](https://so.csdn.net/so/search?q=虚拟内存&spm=1001.2101.3001.7020)
一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间，哪些数据在哪里，都由进程控制表中的task_struct记录，task_struct中记录中一条链表，记录中内存空间的分配情况，哪些地址有数据，哪些地址无数据，哪些可读，哪些可写，都可以通过这个链表记录
​    每个进程已经分配的内存空间，都与对应的磁盘空间映射 
 
​    每个程序都能看到一片完整连续的地址空间，这些空间并没有直接关联到物理内存，而是操作系统提供了内存的一种抽象概念，使得每个进程都有一个连续完整的地址空间，在程序的运行过程，再完成虚拟地址到物理地址的转换。我们同样知道，进程的地址空间是分段的，存在所谓的数据段，代码段，bbs段，堆，栈等等。每个段都有特定的作用。 
同时计算机没有那么多的内存（n个进程就需要对应n*4G内存），建立一个进程，就要把磁盘上的程序文件拷贝到进程对应的内存中去，对于有一个程序对应多个进程这种情况，浪费内存。

### 深入理解

- 每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理地址
- 所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上
- 进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要页表记录
- 页表的每一个表项分为两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存的地址
- 当进程访问某个虚拟地址，去查看页表，如果对应的数据不在物理内存中，，则缺页异常
- 缺页异常的处理过程，就是把进程需要的数据从磁盘拷贝到物理内存中，如果内存已经满了 ，没有空地方，那就找一个页进行覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘

## fork

## PCB

|     进程标识符     |   处理机状态   |      进程调度信息      |    进程控制信息    |
| :----------------: | :------------: | :--------------------: | :----------------: |
|        PID         | 通用寄存器状态 |        进程状态        |  程序和数据的地址  |
|     内部标识符     |                |       进程优先级       | 进程同步和通信机制 |
|     子进程标志     |                | 进程调度所需的其他信息 |      资源清单      |
| 父进程标志（PPID） |                |                        |      链接指针      |
|      用户标志      |                |                        |                    |

**进程标识符**

用户标志：标属该进程属于哪个用户。

进程调度所需的其他信息：与所采用的进程调度算法有关。比如，进程已等待的CPU时间总和、进程已执行时间等。

链接指针：本进程（PCB）所在队列中的下一个进程地PCB的首地址。


# Linux中的虚拟内存数据结构

	使用内核版本:Linux 2.6.32

Linux使用 vm_area_struct 进程的虚拟内存空间划分为多个分区，在Linux内核中
